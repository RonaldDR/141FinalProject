<!DOCTYPE html>
<html>
<head>
	<title>SciDama</title>
	<style type="text/css">
		* {
			margin: 0;
			padding: 0;
		}
		canvas {
			display: block;
		}
	</style>
</head>
<body>
	<canvas id="dama"></canvas>
	<script>
		var canvas = document.getElementById('dama');
		var context = canvas.getContext('2d');
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

		setInterval(world, 30);

		var current = undefined;
		var currfield = undefined;

		var tiles = [];
		var ctr = 0;
		var di = 70;
		var initx = canvas.width/2 - (8 * di) / 2;
		var inity = canvas.height/2 - (8 * di) / 2;
		var p1 = [];
		var p2 = [];
		var field = [];
		var pick = 0;
		var adjacentfields = new Node(-1,-1);
		var turn = 1;
		var adjacents1 = [];
		var adjacents2 = [];
		var multipleadjacents = [];
		var temp = 0;

		function generateTiles() {
			for (var j = inity; j < inity+8*di; j+=di) {
				for (var i = initx; i < initx+8*di; i+=di) {
					tiles.push(new Tile(i,j,ctr%2, 0));
					ctr++;
				}
				ctr++;
			}
		}
		generateTiles();

		function generatePieces() {
			var ctr = 0;
			var y = 0;
			for (var i = 0; i < tiles.length && ctr < 12; i++) {
				if (tiles[i].t == 0) {
					p1.push(new Piece(tiles[i].x, tiles[i].y, 0, y));
					y++;
					ctr++;
				}
			}
			var ctr = 0;
			var z = 31;
			for (var i = tiles.length-1; i >= 0 && ctr < 12; i--) {
				if (tiles[i].t == 0) {
					p2.push(new Piece(tiles[i].x, tiles[i].y, 1, z));
					z--;
					ctr++;
				}
			}

		}
		generatePieces();

		function generateField(){
			var j = 0;
			for(var i = 0; i < tiles.length; i++){
				if(tiles[i].t == 0){
					if(i < 24){
						field.push(new Tile(tiles[i].x, tiles[i].y, 0, 1));
					}
					else if(i > 39){
						field.push(new Tile(tiles[i].x, tiles[i].y, 0, 2));
					}
					else{
						field.push(new Tile(tiles[i].x, tiles[i].y, 0, 0));
					}
				}
			}
		}
		generateField();

		function Tile(x, y, t, c) {
			this.x = x;
			this.y = y;
			this.t = t;
			this.c = c;
			this.dim = di;
			this.draw = function() {
				context.fillStyle = this.t == 1 ? '#000' : '#fff';
				context.fillRect(this.x, this.y, this.dim, this.dim);
			}
			this.highlight = function() {
				context.fillStyle = this.p == 1 ? 'rgba(255,0,0,0.3)' : 'rgba(0,0,255,0.3)';
				context.fillRect(this.x, this.y, di, di);
			}
		}

		function Piece(x,y,p, i) {
			this.x = x;
			this.y = y;
			this.p = p;
			this.i = i;
			this.radius = 30;
			this.draw = function() {
				context.fillStyle = this.p == 1 ? '#f00' : '#00f';
				context.beginPath();
				context.arc(this.x + di/2, this.y + di/2, this.radius, Math.PI*2, false);
				context.fill();
			}			
		}

		function Node(l, r){
			this.right = r;
			this.left = l;
		}
// =============================MINI FUNCS============================
		function clearCanvas() {
			context.fillStyle = '#666';
			context.fillRect(0,0,canvas.width,canvas.height);
		}
		function getHyp(x1,y1,x2,y2) {
			var diffx = x1 - x2;
			var diffy = y1 - y2;
			return Math.sqrt(diffx * diffx + diffy * diffy);
		}
		function fillAdjacents(){
			adjacents1[0] = new Node(-1,4);
			adjacents1[1] = new Node(4,5);
			adjacents1[2] = new Node(5,6);
			adjacents1[3] = new Node(6,7);
			adjacents1[4] = new Node(8,9);
			adjacents1[5] = new Node(9,10);
			adjacents1[6] = new Node(10,11);
			adjacents1[7] = new Node(11,-1);
			adjacents1[8] = new Node(-1,12);
			adjacents1[9] = new Node(12,13);
			adjacents1[10] = new Node(13,14);
			adjacents1[11] = new Node(14,15);
			adjacents1[12] = new Node(16,17);
			adjacents1[13] = new Node(17,18);
			adjacents1[14] = new Node(18,19);
			adjacents1[15] = new Node(19,-1);
			adjacents1[16] = new Node(-1,20);
			adjacents1[17] = new Node(20,21);
			adjacents1[18] = new Node(21,22);
			adjacents1[19] = new Node(22,23);
			adjacents1[20] = new Node(24,25);
			adjacents1[21] = new Node(25,26);
			adjacents1[22] = new Node(26,27);
			adjacents1[23] = new Node(27,-1);
			adjacents1[24] = new Node(-1,28);
			adjacents1[25] = new Node(28,29);
			adjacents1[26] = new Node(29,30);
			adjacents1[27] = new Node(30,31);
			adjacents1[28] = new Node(-1,-1);
			adjacents1[29] = new Node(-1,-1);
			adjacents1[30] = new Node(-1,-1);
			adjacents1[31] = new Node(-1,-1);

			adjacents2[0] = new Node(-1,-1);
			adjacents2[1] = new Node(-1,-1);
			adjacents2[2] = new Node(-1,-1);
			adjacents2[3] = new Node(-1,-1);
			adjacents2[4] = new Node(0,1);
			adjacents2[5] = new Node(1,2);
			adjacents2[6] = new Node(2,3);
			adjacents2[7] = new Node(3,-1);
			adjacents2[8] = new Node(-1,4);
			adjacents2[9] = new Node(4,5);
			adjacents2[10] = new Node(5,6);
			adjacents2[11] = new Node(6,7);
			adjacents2[12] = new Node(8,9);
			adjacents2[13] = new Node(9,10);
			adjacents2[14] = new Node(10,11);
			adjacents2[15] = new Node(11,-1);
			adjacents2[16] = new Node(-1,12);
			adjacents2[17] = new Node(12,13);
			adjacents2[18] = new Node(13,14);
			adjacents2[19] = new Node(14,15);
			adjacents2[20] = new Node(16,17);
			adjacents2[21] = new Node(17,18);
			adjacents2[22] = new Node(18,19);
			adjacents2[23] = new Node(19,-1);
			adjacents2[24] = new Node(-1,20);
			adjacents2[25] = new Node(20,21);
			adjacents2[26] = new Node(21,22);
			adjacents2[27] = new Node(22,23);
			adjacents2[28] = new Node(24,25);
			adjacents2[29] = new Node(25,26);
			adjacents2[30] = new Node(26,27);
			adjacents2[31] = new Node(27,-1);
		}
		fillAdjacents();
		function getAdj(x, p){
			var adjarr = new Node(-1,-1);
			if (p == 1) {
				adjarr.right = adjacents1[x].right;					// retrieve adjacents
				adjarr.left = adjacents1[x].left;					// retrieve adjacents
				if(adjarr.right != -1 && adjarr.left != -1){
					if(field[adjarr.right].c == 2){				// if adjacent is not empty
						adjarr.right = adjacents1[adjarr.right].right;
					}
					else if(field[adjarr.right].c == 1){
						adjarr.right = -1;
					}
					if(field[adjarr.left].c == 2){
						adjarr.left = adjacents1[adjarr.left].left;
					}
					else if(field[adjarr.left].c == 1){
						adjarr.left = -1;
					}
				}
				if(adjarr.right != -1 && adjarr.left == -1){	// if move to right is possible and move to left is not
					if(field[adjarr.right].c == 2){				// if adjacent is not empty
						adjarr.right = adjacents1[adjarr.right].right;
					}
					else if(field[adjarr.right].c == 1){
						adjarr.right = -1;
					}
				}
				if(adjarr.right == -1 && adjarr.left != -1){	// if move to right is not and move to left is possible
					if(field[adjarr.left].c == 2){
						adjarr.left = adjacents1[adjarr.left].left;
					}
					else if(field[adjarr.left].c == 1){
						adjarr.left = -1;
					}
				}
			}
			else {
				adjarr.right = adjacents2[x].right;					// retrieve adjacents
				adjarr.left = adjacents2[x].left;					// retrieve adjacents
				if(adjarr.right != -1 && adjarr.left != -1){
					if(field[adjarr.right].c == 1){				// if adjacent is not empty
						adjarr.right = adjacents2[adjarr.right].right;
					}
					else if(field[adjarr.right].c == 2){
						adjarr.right = -1;
					}
					if(field[adjarr.left].c == 1){
						adjarr.left = adjacents2[adjarr.left].left;
					}
					else if(field[adjarr.left].c == 2){
						adjarr.left = -1;
					}
				}
				if(adjarr.right != -1 && adjarr.left == -1){	// move to right is possible and move to left is not
					if(field[adjarr.right].c == 1){				// if adjacent is not empty
						adjarr.right = adjacents2[adjarr.right].right;
					}
					else if(field[adjarr.right].c == 2){
						adjarr.right = -1;
					}
				}
				if(adjarr.right == -1 && adjarr.left != -1){
					if(field[adjarr.left].c == 1){
						adjarr.left = adjacents2[adjarr.left].left;
					}
					else if(field[adjarr.left].c == 2){
						adjarr.left = -1;
					}
				}
			}			
			return adjarr;
		}
		function contains(x, arr){
			if(x == arr.right || x == arr.left)
				return true;
			else
				return false;
		}
		function sendNodes(x, p){
			if(p == 1){
				if(x.left != -1){
					multipleadjacents.push(x.left);
					sendNodes(adjacents1(x.left));
				}
				if(x.right != -1){
					multipleadjacents.push(x.right);
					sendNodes(adjacents1(x.right));
				}
			}
			if(p == 2){
				if(x.left != -1){
					multipleadjacents.push(x.left);
					sendNodes(adjacents2(x.left));
				}
				if(x.right != -1){
					multipleadjacents.push(x.right);
					sendNodes(adjacents2(x.right));
				}
			}
			return;
		}
//===================================================================
		function world() {
			clearCanvas();
			for (var i = 0; i < tiles.length; i++) {
				tiles[i].draw();
			}
			for (var i = 0; i < p1.length; i++) {
				p1[i].draw();
			}	
			for (var i = 0; i < p2.length; i++) {
				p2[i].draw();
			}

			if(adjacentfields.right != -1){
				field[adjacentfields.right].highlight();
			}
			if(adjacentfields.left != -1){
				field[adjacentfields.left].highlight();
			}

			if(currfield && pick == 1){
				currfield.highlight();
			}
		}

		window.addEventListener('click', function(e) {
			if(pick == 1){
				// dropping piece
				for(var i = 0; i< 32; i++){
					if(getHyp(e.pageX, e.pageY, field[i].x + di / 2, field[i].y + di / 2) <= 30 && current && field[i].c == 0){
						if(contains(i, adjacentfields)){
							current.x = field[i].x;			// selected piece.x = wheredropped.x
							current.y = field[i].y;			// selected piece.y = wheredropped.y
							current.i = i;					// selected piece position, changed
							pick = 0;						// status: piece dropped

							if(turn == 1){					// change turn
								field[i].c = 1;				// wheredropped field status = occupied 
								if(adjacentfields.right != adjacents1[temp].right){	// check if enemy eaten
									for(var i = 0; i < p2.length; i++){
										if(p2[i].i == adjacents1[temp].right){		// know eaten piece
											p2.splice(i,1);
										}
									}
									
								}
								if(adjacentfields.left != adjacents1[temp].left){	// check if enemy eaten
									for(var i = 0; i < p2.length; i++){
										if(p2[i].i == adjacents1[temp].left){		// know eaten piece
											p2.splice(i,1);
										}
									}
								}
								turn = 2;
							}
							else{
								field[i].c = 2;					// wheredropped field status = occupied
								if(adjacentfields.right != adjacents2[temp].right){	// check of enemy eaten
									for(var i = 0; i < p1.length; i++){
										if(p1[i].i == adjacents2[temp].right){		// know eaten piece
											p1.splice(i,1);
										}
									}
								}
								if(adjacentfields.left != adjacents2[temp].left){	// check of enemy eaten
									for(var i = 0; i < p1.length; i++){
										if(p1[i].i == adjacents2[temp].left){		// know eaten piece
											p1.splice(i,1);
										}
									}
								}
								turn = 1;
							}
							adjacentfields = new Node(-1,-1);	// empty adjacent fields
						}
						if(field[i] == currfield){			// drop piece on place
							field[i].c = turn;
							pick = 0;						
							adjacentfields = new Node(-1,-1); // para highlight ra
						}
					}
				}
			}
			else if(pick == 0){
				// picking up piece
				if(turn == 1){
					for (var i = 0; i < p1.length; i++) {
						if (getHyp(e.pageX, e.pageY, p1[i].x + di / 2, p1[i].y + di / 2) <= p1[i].radius) {
							current = p1[i];				// selected piece
							currfield = field[current.i];	// corresponding field
							field[current.i].c = 0;			// corresponding field status = not occupied
							pick = 1;						// status: piece picked
							adjacentfields = getAdj(current.i, 1); // collection of adjacent fields
							temp = current.i;
						}
					}
				}
				if(turn == 2){
					for (var i = 0; i < p2.length; i++) {
						if (getHyp(e.pageX, e.pageY, p2[i].x + di / 2, p2[i].y + di / 2) <= p2[i].radius) {
							current = p2[i];				// selected piece
							currfield = field[current.i];	// corresponding field
							field[current.i].c = 0;			// corresponding field status = not occupied
							pick = 1;						// status: piece picked
							adjacentfields = getAdj(current.i, 2); // collection of adjacent fields
							temp = current.i;
						}
					}
				}
			}
			
		});
	</script>
</body>
</html>